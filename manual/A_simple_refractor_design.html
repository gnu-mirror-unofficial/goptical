<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
 <meta name="Generator" content="MKDOC " />
 <title>GNU Goptical manual </title>
 <link rel="stylesheet" href="mkdoc.css" />
 <style type="text/css">

  .sec_hidden { display: none; }
  .sec_shown {}
 </style>
</head><body>
<div class="page"><div class="head"><div class="headlinks"><a href="Table_of_contents.html">Table of contents</a>
 &nbsp; <a href="Introduction.html">Introduction</a>
 &nbsp; <a href="Tutorial.html">Tutorial</a>
 &nbsp; <a href="Main_classes.html">Main classes</a>
</div><div class="navlinks"><a href="index.html" accesskey="t">Top</a> &nbsp; <a href="Tutorial.html"  accesskey="u" id="nav_up"> Up </a> &nbsp; <a href="A_photo_lens_design.html"  accesskey="n" id="nav_next"> Next</a></div>
</div><div class="content"><div style="clear: both; height:20px;"></div>
<h1>3.1 A simple refractor design</h1><div class="sec_content1">
<div style="clear: both; height:20px;"></div>
<div class="img_frame"><img src="refractor_layout.png" alt="Refractor optical system 2d layout" /><div class="img_caption">Refractor optical system 2d layout</div>
</div></div><h2>3.1.1 Building the optical system<a href="#_Building_the_optical_system" id="_Building_the_optical_system" class="hover_link">&nbsp;&nbsp;</a></h2><div class="sec_content2">
<p>Unlike much optical design software which relies on a list of surfaces to sequentially propagate light through the system, Goptical uses an object representation of the optical system in 3d space.</p>
<p>To model an optical system with Goptical, we just have to instantiate components and add them to the system.</p>
<p>For this refractor example we first need to deal with glass materials used in the design. Our achromatic refractor design needs two lenses of different glass materials. In this example we choose to model Bk7 and F3 glasses with the Sellmeier model:</p>
<div class="codebox"><code><span class="codecmt">// code from <a href="http://hg.savannah.gnu.org/hgweb/goptical/file/ff428b6d3967/examples/simple_refractor/refractor.cc#l64">examples/simple_refractor/refractor.cc:64</a></span><br /><br />  <a class="coderef" href="Material_Sellmeier_class_reference.html">Material::Sellmeier</a> bk7(1.03961212, 6.00069867e-3, 0.231792344,<br />                          2.00179144e-2, 1.01046945, 1.03560653e2);<br /><br />  <a class="coderef" href="Material_Sellmeier_class_reference.html">Material::Sellmeier</a> f3(8.23583145e-1, 6.41147253e-12, 7.11376975e-1,<br />                         3.07327658e-2, 3.12425113e-2, 4.02094988);<br /></code></div><p> The <span class="codedecl">Sys::<a href="Sys_OpticalSurface_class_reference.html">OpticalSurface</a></span> class is used to model a single optical surface.</p>
<p>The two lenses have the same disk outline shape, so we declare the shape model once:</p>
<div class="codebox"><code>  <a class="coderef" href="Shape_Disk_class_reference.html">Shape::Disk</a>   lens_shape(100); <span class="codecmt">// lens diameter is 100mm</span><br /><br />  <span class="codecmt">// 1st lens, left surface</span><br />  <a class="coderef" href="Curve_Sphere_class_reference.html">Curve::Sphere</a> curve1(2009.753); <span class="codecmt">// spherical curve with given radius of curvature</span><br />  <a class="coderef" href="Curve_Sphere_class_reference.html">Curve::Sphere</a> curve2(-976.245);<br /></code></div><p> Surface curves rely on dedicated models which are not dependent on optical component being used. Here we need two simple spherical curves for the first lens.</p>
<p>The first lens component can then be instantiated. We need to specify its 3d position, thickness, shape model, curve models and material models. <span class="codedecl">Material::<a href="Material_namespace_reference.html#__528">none</a></span> will later be replaced by system environment material.</p>
<div class="codebox"><code>  <a class="coderef" href="Sys_OpticalSurface_class_reference.html">Sys::OpticalSurface</a> s1(<a class="coderef" href="Math_namespace_reference.html#__653">Math::Vector3</a>(0, 0, 0), <span class="codecmt">// position,</span><br />                         curve1, lens_shape,     <span class="codecmt">// curve &amp; aperture shape</span><br />                         <a class="coderef" href="Material_namespace_reference.html#__528">Material::none</a>, bk7);   <span class="codecmt">// materials</span><br /><br />  <span class="codecmt">// 1st lens, right surface</span><br />  <a class="coderef" href="Sys_OpticalSurface_class_reference.html">Sys::OpticalSurface</a> s2(<a class="coderef" href="Math_namespace_reference.html#__653">Math::Vector3</a>(0, 0, 31.336),<br />                         curve2, lens_shape,<br />                         bk7, <a class="coderef" href="Material_namespace_reference.html#__528">Material::none</a>);<br /></code></div><p> More convenient optical surface constructors are available for simple cases, with circular aperture and spherical curvature. They are used for the second lens:</p>
<div class="codebox"><code>  <span class="codecmt">// 2nd lens, left surface</span><br />  <a class="coderef" href="Sys_OpticalSurface_class_reference.html">Sys::OpticalSurface</a> s3(<a class="coderef" href="Math_namespace_reference.html#__653">Math::Vector3</a>(0, 0, 37.765), <span class="codecmt">// position,</span><br />                         -985.291, 100,        <span class="codecmt">// roc &amp; circular aperture radius,</span><br />                         <a class="coderef" href="Material_namespace_reference.html#__528">Material::none</a>, f3);  <span class="codecmt">// materials</span><br /><br />  <span class="codecmt">// 2nd lens, right surface</span><br />  <a class="coderef" href="Sys_OpticalSurface_class_reference.html">Sys::OpticalSurface</a> s4(<a class="coderef" href="Math_namespace_reference.html#__653">Math::Vector3</a>(0, 0, 37.765+25.109),<br />                         -3636.839, 100,<br />                         f3, <a class="coderef" href="Material_namespace_reference.html#__528">Material::none</a>);<br /></code></div><p> The <span class="codedecl">Sys::<a href="Sys_Lens_class_reference.html">Lens</a></span> class is more convenient to use for most designs as it can handle a list of surfaces. In this example we choose to use the <span class="codedecl">Sys::<a href="Sys_OpticalSurface_class_reference.html">OpticalSurface</a></span> class directly to show how things work. The convenient method is used in <a href="A_photo_lens_design.html">the next example</a>.</p>
<p>We then create a point light source at infinite distance with a direction vector aimed at entry surface (left of first lens):</p>
<div class="codebox"><code>  <span class="codecmt">// light source</span><br />  <a class="coderef" href="Sys_SourcePoint_class_reference.html">Sys::SourcePoint</a> source(<a class="coderef" href="Sys_namespace_reference.html#__1192">Sys::SourceAtInfinity</a>,<br />                          <a class="coderef" href="Math_namespace_reference.html#__653">Math::Vector3</a>(0, 0, 1));<br /></code></div><p> And we finally create an image plane near the expected focal point:</p>
<div class="codebox"><code>  <span class="codecmt">// image plane</span><br />  <a class="coderef" href="Sys_Image_class_reference.html">Sys::Image</a>    image(<a class="coderef" href="Math_namespace_reference.html#__653">Math::Vector3</a>(0, 0, 3014.5),  <span class="codecmt">// position</span><br />                      60);                           <span class="codecmt">// square size,</span><br /></code></div><p> All these components need to be added to an optical system:</p>
<div class="codebox"><code>  <a class="coderef" href="Sys_System_class_reference.html">Sys::System</a>   sys;<br /><br />  <span class="codecmt">// add components</span><br />  sys.add(source);<br />  sys.add(s1);<br />  sys.add(s2);<br />  sys.add(s3);<br />  sys.add(s4);<br />  sys.add(image);<br /></code></div><p> This simple optical design is ready for ray tracing and analysis.</p>
</div><h2>3.1.2 Performing light propagation<a href="#_Performing_light_propagation" id="_Performing_light_propagation" class="hover_link">&nbsp;&nbsp;</a></h2><div class="sec_content2">
<p>Light propagation through the optical system is performed by the <span class="codedecl">Trace::<a href="Trace_Tracer_class_reference.html">Tracer</a></span> class. There are several tracer parameters which can be tweaked before starting light propagation. Some default parameters can be set for an optical system instance; they will be used for each new tracer created for the system.</p>
<p>When light is propagated through the system, a tracer may be instructed to keep track of rays hitting or generated by some of the components for further analysis.</p>
<p>Some <a href="Analysis_namespace_reference.html">analysis classes</a> are provided which embed a tracer configured for a particular analysis, but it's still possible to request a light propagation by directly instantiating a tracer object.</p>
<p>There are two major approaches to trace rays through an optical system:</p>
<ul><li><p>Sequential ray tracing: This requires an ordered list of surfaces to traverse. Rays are generated by the light source and propagated in the specified sequence order. Any light ray which doesn't reach the next surface in order is lost.</p>
</li>
<li><p>Non-sequential ray tracing: Rays are generated by the light source and each ray interacts with the first optical component found on its path. Rays are propagated this way across system components until they reach an image plane or get lost.</p>
</li>
</ul>
<p>The default behavior in Goptical is to perform a non-sequential ray trace when no sequence is provided.</p>
</div><h3>Non-sequential ray trace<a href="#_Non_sequential_ray_trace" id="_Non_sequential_ray_trace" class="hover_link">&nbsp;&nbsp;</a></h3><div class="sec_content3">
<p> A non-sequential ray trace needs the specification of an entrance pupil so that rays from light sources can be targeted at optical system entry.</p>
<p>Performing light propagation only needs instantiation of a <span class="codedecl">Trace::<a href="Trace_Tracer_class_reference.html">Tracer</a></span> object and invocation of its <span class="codedecl">Trace::Tracer::<a href="Trace_Tracer_class_reference.html#__1425">trace</a></span> function. Tracer parameters are inherited from system default tracer parameters:</p>
<div class="codebox"><code>  sys.set_entrance_pupil(s1);<br />  <a class="coderef" href="Trace_Tracer_class_reference.html">Trace::Tracer</a> tracer(sys);<br />  tracer.trace();<br /></code></div><p> When performing a non-sequential ray trace, only optical components based on <span class="codedecl">Sys::<a href="Sys_Surface_class_reference.html">Surface</a></span> will interact with light.</p>
<p>All enabled light sources which are part of the system are considered.</p>
</div><h3>Sequential ray trace<a href="#_Sequential_ray_trace" id="_Sequential_ray_trace" class="hover_link">&nbsp;&nbsp;</a></h3><div class="sec_content3">
<p> Switching to a sequential ray trace is easy: The sequence is setup from components found in the system, in order along the Z axis.</p>
<div class="codebox"><code>  <a class="coderef" href="Trace_Sequence_class_reference.html">Trace::Sequence</a> seq(sys);<br /><br />  sys.get_tracer_params().set_sequential_mode(seq);<br /></code></div><p> More complicated sequences must be created empty and described explicitly using the <span class="codedecl">Trace::Sequence::<a href="Trace_Sequence_class_reference.html#__1410">add</a></span> function.</p>
<p>Optical system and sequence objects can be displayed using stl streams:</p>
<div class="codebox"><code>  std::cout &lt;&lt; <span class="codestr">&quot;system:&quot;</span> &lt;&lt; std::endl &lt;&lt; sys;<br />  std::cout &lt;&lt; <span class="codestr">&quot;sequence:&quot;</span> &lt;&lt; std::endl &lt;&lt; seq;<br /></code></div><p> Ray tracing is then performed in the same way as for non-sequential ray traces:</p>
<div class="codebox"><code>  <a class="coderef" href="Trace_Tracer_class_reference.html">Trace::Tracer</a> tracer(sys);<br />  tracer.trace();<br /></code></div><p> When performing a sequential ray trace, all optical components can process incoming light rays.</p>
<p>A single light source must be present at the beginning of the sequence.</p>
</div><h2>3.1.3 Rendering optical layout and rays<a href="#_Rendering_optical_layout_and_rays" id="_Rendering_optical_layout_and_rays" class="hover_link">&nbsp;&nbsp;</a></h2><div class="sec_content2">
<p>The result of ray tracing is stored in a <span class="codedecl">Trace::<a href="Trace_Result_class_reference.html">Result</a></span> object which stores information about generated and intercepted rays and involved components for each ray. Not all rays' interactions are stored by default, and the result object must be first configured to specify which interactions should be stored for further analysis.</p>
<p>Here we want to draw all rays which are traced through the system. We first have to instruct our <span class="codedecl">Trace::<a href="Trace_Result_class_reference.html">Result</a></span> object to remember which rays were generated by the source component in the system, so that it can used as a starting point for drawing subsequently scattered and reflected rays.</p>
<p>We use an <span class="codedecl">Io::<a href="Io_Renderer_class_reference.html">Renderer</a></span> based object which is able to draw various things. We use it to draw system components as well as to recursively draw all rays generated by light sources.</p>
<p>Here is what we need to do in order:</p>
<ul><li><p>Instantiate a renderer object able to write graphics in some output format.</p>
</li>
<li><p>Fit renderer viewport to optical system.</p>
</li>
<li><p>Draw system components.</p>
</li>
<li><p>Optionally change the ray distribution on entrance pupil so that only meridional rays are traced.</p>
</li>
<li><p>Instruct the result object to keep track of rays generated by the source component.</p>
</li>
<li><p>Perform the ray tracing.</p>
</li>
<li><p>Draw traced rays.</p>
</li>
</ul>
<div class="codebox"><code>  <a class="coderef" href="Io_RendererSvg_class_reference.html">Io::RendererSvg</a> renderer(<span class="codestr">&quot;layout.svg&quot;</span>, 1024, 100);<br /><br />  <span class="codecmt">// draw 2d system layout</span><br />  sys.draw_2d_fit(renderer);<br />  sys.draw_2d(renderer);<br /><br />  <a class="coderef" href="Trace_Tracer_class_reference.html">Trace::Tracer</a> tracer(sys);<br /><br />  <span class="codecmt">// trace and draw rays from source</span><br />  tracer.get_params().set_default_distribution(<br />    <a class="coderef" href="Trace_Distribution_class_reference.html">Trace::Distribution</a>(<a class="coderef" href="Trace_namespace_reference.html#__1354">Trace::MeridionalDist</a>, 5));<br />  tracer.get_trace_result().set_generated_save_state(source);<br />  tracer.trace();<br />  tracer.get_trace_result().draw_2d(renderer);<br /></code></div></div><h2>3.1.4 Performing a ray fan analysis<a href="#_Performing_a_ray_fan_analysis" id="_Performing_a_ray_fan_analysis" class="hover_link">&nbsp;&nbsp;</a></h2><div class="sec_content2">
<p>The <span class="codedecl"><a href="Analysis_namespace_reference.html">Analysis</a></span> namespace contains classes to perform some common analysis on optical systems. Analysis classes may embed a <span class="codedecl">Trace::<a href="Trace_Tracer_class_reference.html">Tracer</a></span> object if light propagation is needed to perform analysis.</p>
<p>Ray fan plots can be computed using the <span class="codedecl">Analysis::<a href="Analysis_RayFan_class_reference.html">RayFan</a></span> class which is able to plot various ray measurements on both 2d plot axes.</p>
<p>The example below shows how to produce a transverse aberration plot by plotting entrance ray height against transverse distance:</p>
<div class="codebox"><code>  <a class="coderef" href="Io_RendererSvg_class_reference.html">Io::RendererSvg</a>     renderer(<span class="codestr">&quot;fan.svg&quot;</span>, 640, 480, <a class="coderef" href="Io_namespace_reference.html#__353">Io::rgb_white</a>);<br /><br />  <a class="coderef" href="Analysis_RayFan_class_reference.html">Analysis::RayFan</a>    fan(sys);<br /><br />  <span class="codecmt">// select light source wavelens</span><br />  source.clear_spectrum();<br />  source.add_spectral_line(<a class="coderef" href="Light_SpectralLine_class_reference.html#__496">Light::SpectralLine::C</a>);<br />  source.add_spectral_line(<a class="coderef" href="Light_SpectralLine_class_reference.html#__503">Light::SpectralLine::e</a>);<br />  source.add_spectral_line(<a class="coderef" href="Light_SpectralLine_class_reference.html#__499">Light::SpectralLine::F</a>);<br /><br />  <span class="codecmt">// get transverse aberration plot</span><br />  <a class="coderef" href="http://diaxen.ssji.net/dpp/ref_class_reference.html">ref</a>&lt;<a class="coderef" href="Data_Plot_class_reference.html">Data::Plot</a>&gt; fan_plot = fan.get_plot(<a class="coderef" href="Analysis_RayFan_class_reference.html#__8">Analysis::RayFan::EntranceHeight</a>,<br />                                          <a class="coderef" href="Analysis_RayFan_class_reference.html#__8">Analysis::RayFan::TransverseDistance</a>);<br /><br />  fan_plot-&gt;draw(renderer);<br /></code></div><div class="img_frame"><img src="refractor_fan.png" /></div></div></div></div><div class="foot"><p class="generated"><a style="float: right;" href="http://validator.w3.org/check?uri=referer">Valid XHTML 1.0 Strict</a>Generated by diaxen on Sun Jan  8 00:47:23 2012 using <a href="http://www.nongnu.org/mkdoc/">MkDoc</a></p></div></body></html>