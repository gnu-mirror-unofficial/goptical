<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
 <meta name="Generator" content="MKDOC " />
 <title>GNU Goptical manual </title>
 <link rel="stylesheet" href="mkdoc.css" />
 <style type="text/css">

  .sec_hidden { display: none; }
  .sec_shown {}
 </style>
</head><body>
<div class="page"><div class="head"><div class="headlinks"><a href="Table_of_contents.html">Table of contents</a>
 &nbsp; <a href="Introduction.html">Introduction</a>
 &nbsp; <a href="Tutorial.html">Tutorial</a>
 &nbsp; <a href="Main_classes.html">Main classes</a>
</div><div class="navlinks"><a href="index.html" accesskey="t">Top</a> &nbsp; <a href="A_parameterizable_segmented_mirror_model.html"  accesskey="p" id="nav_prev">Previous </a> &nbsp; <a href="Tutorial.html"  accesskey="u" id="nav_up"> Up </a></div>
</div><div class="content"><div style="clear: both; height:20px;"></div>
<h1>3.5 A custom surface curve model</h1><div class="sec_content1">
<div style="clear: both; height:20px;"></div>
<p>Common curve models are available in the <span class="codedecl"><a href="Curve_namespace_reference.html">Curve</a></span> namespace but extending this set with user-defined models is easy, as explained in this tutorial.</p>
</div><h2>3.5.1 Writing the curve model class<a href="#_Writing_the_curve_model_class" id="_Writing_the_curve_model_class" class="hover_link">&nbsp;&nbsp;</a></h2><div class="sec_content2">
<p>In this example, we chose to model a rotationally symmetric <span class="ext_link"><a href="http://en.wikipedia.org/wiki/Catenary">catenary</a></span> curve. This curve has the following sagitta formula:</p>
<p><img style="vertical-align: middle;" src="43371755be7caeef19434888ace2032a.png" alt="z = a \, \cosh \left ({r \over a} \right ) - a" /></p>
<p>Our curve model needs to provide several functions in order to be useful to the raytracer. Fortunately there are base classes which provide default implementations for most curve model functions. This include differentiation functions and ray intersection functions.</p>
<p>The <span class="codedecl">Curve::<a href="Curve_Rotational_class_reference.html">Rotational</a></span> class allows modeling rotationally symmetric curves by only dealing with 2d formulas. Our model class just has to inherit from this class and provide an implementation for the <span class="tt">sagitta</span> function:</p>
<div class="codebox"><code><span class="codecmt">// code from <a href="http://hg.savannah.gnu.org/hgweb/goptical/file/ff428b6d3967/examples/curve_model/usercurve.cc#l56">examples/curve_model/usercurve.cc:56</a></span><br /><br /><span class="codekw">class</span> MyCatenaryCurve : <span class="codekw">public</span> <a class="coderef" href="Curve_Rotational_class_reference.html">Curve::Rotational</a><br />{<br /><span class="codekw">public</span>:<br />  MyCatenaryCurve(<span class="codetype">double</span> a)<br />    : _a(a)<br />  {<br />  }<br /><br /><span class="codekw">private</span>:<br />  <span class="codetype">double</span> sagitta(<span class="codetype">double</span> r) <span class="codekw">const</span><br />  {<br />    <span class="codekw">return</span> _a * cosh(r / _a) - _a;<br />  }<br /><br />  <span class="codetype">double</span> _a;<br />};<br /></code></div><p> The model can be improved by specifying the derivative function. This make calculations more efficient by avoiding use of the default numerical differentiation implementation:</p>
<div class="codebox"><code>  <span class="codetype">double</span> derivative(<span class="codetype">double</span> r) <span class="codekw">const</span><br />  {<br />    <span class="codekw">return</span> sinh(r / _a);<br />  }<br /></code></div><p> Although more functions from <span class="codedecl">Curve::<a href="Curve_Base_class_reference.html">Base</a></span> and <span class="codedecl">Curve::<a href="Curve_Rotational_class_reference.html">Rotational</a></span> can be reimplemented to further improve model efficiency, this curve model can readily be used in an optical design.</p>
</div><h2>3.5.2 Using the new model in optical design<a href="#_Using_the_new_model_in_optical_design" id="_Using_the_new_model_in_optical_design" class="hover_link">&nbsp;&nbsp;</a></h2><div class="sec_content2">
<p>To check our model, we then use it in a simple optical system composed of a point source, a mirror and an image plane. The catenary mirror resemble a parabolic mirror as used in a newton telescope.</p>
<div class="codebox"><code>  <a class="coderef" href="Sys_System_class_reference.html">Sys::System</a>             sys;<br /><br />  <span class="codecmt">// light source</span><br />  <a class="coderef" href="Sys_SourcePoint_class_reference.html">Sys::SourcePoint</a>        source(<a class="coderef" href="Sys_namespace_reference.html#__1192">Sys::SourceAtInfinity</a>, <a class="coderef" href="Math_namespace_reference.html#__680">Math::vector3_001</a>);<br />  sys.add(source);<br /><br />  <span class="codecmt">// mirror</span><br />  <a class="coderef" href="Shape_Disk_class_reference.html">Shape::Disk</a>             shape(200);<br />  MyCatenaryCurve         curve(-3000);<br />  <a class="coderef" href="Sys_Mirror_class_reference.html">Sys::Mirror</a>             primary(<a class="coderef" href="Math_namespace_reference.html#__653">Math::Vector3</a>(0, 0, 1500), curve, shape);<br /><br />  sys.add(primary);<br /><br />  <span class="codecmt">// image plane</span><br />  <a class="coderef" href="Sys_Image_class_reference.html">Sys::Image</a>              image(<a class="coderef" href="Math_namespace_reference.html#__679">Math::vector3_0</a>, 15);<br />  sys.add(image);<br /></code></div><p> The best point of focus is slightly offset from the parabola focal length. We use the <span class="codedecl">Analysis::<a href="Analysis_Focus_class_reference.html">Focus</a></span> class to find the best point of focus and move the image plane at this location:</p>
<div class="codebox"><code>    <a class="coderef" href="Analysis_Focus_class_reference.html">Analysis::Focus</a>               focus(sys);<br /><br />    image.set_plane(focus.get_best_focus());<br /></code></div><p> Finally we plot some spot diagrams using the <span class="codedecl">Analysis::<a href="Analysis_Spot_class_reference.html">Spot</a></span> class. The point light source is rotated for each diagram:</p>
<div class="codebox"><code>    <a class="coderef" href="Io_RendererSvg_class_reference.html">Io::RendererSvg</a>            renderer(<span class="codestr">&quot;spot.svg&quot;</span>,        200 * 3, 200 * 2, <a class="coderef" href="Io_namespace_reference.html#__344">Io::rgb_black</a>);<br /><br />    renderer.set_margin_ratio(.35, .25, .1, .1);<br />    renderer.set_page_layout(3, 2);<br /><br />    <span class="codekw">for</span> (<span class="codetype">int</span> i = 0; i &lt; 6; i++)<br />      {<br />        <a class="coderef" href="Analysis_Spot_class_reference.html">Analysis::Spot</a> spot(sys);<br /><br />        renderer.set_page(i);<br />        spot.draw_diagram(renderer);<br /><br />        source.rotate(0, .1, 0);<br />      }<br /></code></div><div class="img_frame"><img src="catenary_spot.png" alt="Spot diagrams with image at best point of focus for the catenary curve" /><div class="img_caption">Spot diagrams with image at best point of focus for the catenary curve</div>
</div></div></div></div><div class="foot"><p class="generated"><a style="float: right;" href="http://validator.w3.org/check?uri=referer">Valid XHTML 1.0 Strict</a>Generated by diaxen on Sun Jan  8 00:47:23 2012 using <a href="http://www.nongnu.org/mkdoc/">MkDoc</a></p></div></body></html>