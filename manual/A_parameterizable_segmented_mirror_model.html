<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
 <meta name="Generator" content="MKDOC " />
 <title>GNU Goptical manual </title>
 <link rel="stylesheet" href="mkdoc.css" />
 <style type="text/css">

  .sec_hidden { display: none; }
  .sec_shown {}
 </style>
</head><body>
<div class="page"><div class="head"><div class="headlinks"><a href="Table_of_contents.html">Table of contents</a>
 &nbsp; <a href="Introduction.html">Introduction</a>
 &nbsp; <a href="Tutorial.html">Tutorial</a>
 &nbsp; <a href="Main_classes.html">Main classes</a>
</div><div class="navlinks"><a href="index.html" accesskey="t">Top</a> &nbsp; <a href="System_hierarchy_and_groups.html"  accesskey="p" id="nav_prev">Previous </a> &nbsp; <a href="Tutorial.html"  accesskey="u" id="nav_up"> Up </a> &nbsp; <a href="A_custom_surface_curve_model.html"  accesskey="n" id="nav_next"> Next</a></div>
</div><div class="content"><div style="clear: both; height:20px;"></div>
<h1>3.4 A parameterizable segmented mirror model</h1><div class="sec_content1">
<div style="clear: both; height:20px;"></div>
<p>This section shows how to take advantages of the <a href="System_hierarchy_and_groups.html">hierarchical design</a> feature of Goptical to write your own parameterizable optical component models. The code of a segmented mirror component model is presented and this new component is used as the primary mirror in a Ritchey-Chretien telescope design.</p>
<div class="img_frame"><img src="hexseg_mirror.png" alt="3d layout of a Ritchey-Chretien telescope with segmented primary mirror (X3D output)" /><div class="img_caption">3d layout of a Ritchey-Chretien telescope with segmented primary mirror (X3D output)</div>
</div></div><h2>3.4.1 Writing the component model class<a href="#_Writing_the_component_model_class" id="_Writing_the_component_model_class" class="hover_link">&nbsp;&nbsp;</a></h2><div class="sec_content2">
<p>The segmented mirror model uses hexagonal segments and takes a surface curve model, an aperture shape model, segment size and segment separation as parameters. We start the definition of our model class which inherits from the <span class="codedecl">Sys::<a href="Sys_Group_class_reference.html">Group</a></span> class:</p>
<div class="codebox"><code><span class="codecmt">// code from <a href="http://svn.savannah.gnu.org/viewvc/trunk/goptical/examples/segmented_mirror/segmented.cc?annotate=1&root=goptical&revision=1#l62">examples/segmented_mirror/segmented.cc:62</a></span><br /><br /><span class="codekw">class</span> HexSegMirror : <span class="codekw">public</span> <a class="coderef" href="Sys_Group_class_reference.html">Sys::Group</a><br />{<br /><span class="codekw">public</span>:<br /><br />  HexSegMirror(<span class="codekw">const</span> <a class="coderef" href="Math_namespace_reference.html#__654">Math::VectorPair3</a> &amp;pos,<br />               <span class="codekw">const</span> <a class="coderef" href="http://diaxen.ssji.net/dpp/const_ref_class_reference.html">const_ref</a>&lt;<a class="coderef" href="Curve_Base_class_reference.html">Curve::Base</a>&gt; &amp;curve,<br />               <span class="codekw">const</span> <a class="coderef" href="http://diaxen.ssji.net/dpp/const_ref_class_reference.html">const_ref</a>&lt;<a class="coderef" href="Shape_Base_class_reference.html">Shape::Base</a>&gt; &amp;shape,<br />               <span class="codetype">double</span> seg_radius, <span class="codetype">double</span> separation)<br />    : <a class="coderef" href="Sys_Group_class_reference.html">Sys::Group</a>(pos)<br />  {<br /></code></div><p> When the model is instantiated, all hexagonal mirrors need to be created from the constructor. We use two loops in order to build the hexagonal mirror tessellation:</p>
<div class="codebox"><code>    <span class="codekw">if</span> (seg_radius &gt; separation)<br />      <span class="codekw">throw</span>(<a class="coderef" href="Error_class_reference.html">Error</a>(<span class="codestr">&quot;overlapping segments&quot;</span>));<br /><br />    <span class="codecmt">// sqrt(3)/2</span><br />    <span class="codekw">static</span> <span class="codekw">const</span> <span class="codetype">double</span> sqrt_3_2 = 0.86602540378443864676;<br /><br />    <span class="codecmt">// hexagonal tessellation</span><br />    <span class="codetype">int</span> x_count = ceil(shape-&gt;max_radius() / (separation * 1.5));<br />    <span class="codetype">int</span> y_count = ceil(shape-&gt;max_radius() / (separation * 2 * sqrt_3_2));<br /><br />    <span class="codekw">for</span> (<span class="codetype">int</span> x = -x_count; x &lt;= x_count ; x++)<br />      {<br />        <span class="codekw">for</span> (<span class="codetype">int</span> y = -y_count; y &lt;= y_count ; y++)<br />          {<br />            <span class="codecmt">// find segment mirror 2d position</span><br />            <span class="codetype">double</span> yoffset = x % 2 ? separation * sqrt_3_2 : 0;<br />            <a class="coderef" href="Math_namespace_reference.html#__652">Math::Vector2</a> p(x * separation * 1.5,<br />                              yoffset + y * separation * 2 * sqrt_3_2 );<br /></code></div><p> The aperture shape is then used to check if a segment mirror must exist at each location:</p>
<div class="codebox"><code>            <span class="codecmt">// skip if segment center is outside main shape</span><br />            <span class="codekw">if</span> (!shape-&gt;inside(p))<br />              <span class="codekw">continue</span>;<br /></code></div><p> The segment mirror curve must take into account the offset from the main mirror origin. We also decide to subtract the sagitta offset from the segment curve and add it to its Z component position instead; this allows its origin to lie on the segment surface, which may be more convenient when tilting the segment. The <span class="codedecl">Curve::<a href="Curve_Composer_class_reference.html">Composer</a></span> class is used here to apply required transformations to the model curve passed as a parameter:</p>
<div class="codebox"><code>            <span class="codecmt">// find curve z offset at segment center to shift both</span><br />            <span class="codecmt">// curve and segment in opposite directions.</span><br />            <span class="codetype">double</span> z_offset = curve-&gt;sagitta(p);<br /><br />            <span class="codecmt">// create a composer curve for this segment and use it to translate main curve</span><br />            <a class="coderef" href="http://diaxen.ssji.net/dpp/ref_class_reference.html">ref</a>&lt;<a class="coderef" href="Curve_Composer_class_reference.html">Curve::Composer</a>&gt; seg_curve = <a class="coderef" href="http://diaxen.ssji.net/dpp/ref_class_reference.html">ref</a>&lt;<a class="coderef" href="Curve_Composer_class_reference.html">Curve::Composer</a>&gt;::create();<br /><br />            seg_curve-&gt;add_curve(curve).xy_translate(-p).z_offset(-z_offset);<br /></code></div><p> The segment mirror is then created and added to the model group:</p>
<div class="codebox"><code>            <span class="codecmt">// create a segment mirror with hexagonal shape and translated curve</span><br />            <a class="coderef" href="http://diaxen.ssji.net/dpp/ref_class_reference.html">ref</a>&lt;<a class="coderef" href="Sys_Mirror_class_reference.html">Sys::Mirror</a>&gt; seg = <a class="coderef" href="http://diaxen.ssji.net/dpp/ref_class_reference.html">ref</a>&lt;<a class="coderef" href="Sys_Mirror_class_reference.html">Sys::Mirror</a>&gt;::create(<a class="coderef" href="Math_namespace_reference.html#__653">Math::Vector3</a>(p, z_offset), seg_curve,<br />                                             <a class="coderef" href="http://diaxen.ssji.net/dpp/ref_class_reference.html">ref</a>&lt;<a class="coderef" href="Shape_RegularPolygon_class_reference.html">Shape::RegularPolygon</a>&gt;::create(seg_radius, 6));<br /><br />            <span class="codecmt">// attach the new segment to our group component</span><br />            add(seg);<br /></code></div><p> We finally add some code to keep track of the segments so that they can be accessed (and modified) separately after model instantiation:</p>
<div class="codebox"><code>            <span class="codecmt">// keep a pointer to this new segment</span><br />            _segments.push_back(seg.ptr());<br />          }<br />      }<br />  }<br /><br />  <a class="coderef" href="http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/">size_t</a> get_segments_count() <span class="codekw">const</span><br />  {<br />    <span class="codekw">return</span> _segments.size();<br />  }<br /><br />  <a class="coderef" href="Sys_Mirror_class_reference.html">Sys::Mirror</a> &amp; get_segment(<a class="coderef" href="http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/">size_t</a> i) <span class="codekw">const</span><br />  {<br />    <span class="codekw">return</span> *_segments.at(i);<br />  }<br /><br /><span class="codekw">private</span>:<br />  <a class="coderef" href="http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01318.html">std::vector</a>&lt;<a class="coderef" href="Sys_Mirror_class_reference.html">Sys::Mirror</a> *&gt; _segments;<br />};<br /></code></div><p> This model class is less than 70 lines long, including comments.</p>
</div><h2>3.4.2 Using the model in Ritchey-Chretien design<a href="#_Using_the_model_in_Ritchey_Chretien_design" id="_Using_the_model_in_Ritchey_Chretien_design" class="hover_link">&nbsp;&nbsp;</a></h2><div class="sec_content2">
<p>Our new model can now be used like other component models in optical systems and groups. We use it here with a ring aperture shape and conic curvature to model the primary mirror of a Ritchey-Chretien telescope:</p>
<div class="codebox"><code>  <a class="coderef" href="Sys_System_class_reference.html">Sys::System</a>             sys;<br /><br />  <span class="codecmt">// Ring shaped segmented mirror with conic curve</span><br />  HexSegMirror            primary(<a class="coderef" href="Math_namespace_reference.html#__653">Math::Vector3</a>(0, 0, 800),<br />                                  <a class="coderef" href="http://diaxen.ssji.net/dpp/ref_class_reference.html">ref</a>&lt;<a class="coderef" href="Curve_Conic_class_reference.html">Curve::Conic</a>&gt;::create(-1600, -1.0869),<br />                                  <a class="coderef" href="http://diaxen.ssji.net/dpp/ref_class_reference.html">ref</a>&lt;<a class="coderef" href="Shape_Ring_class_reference.html">Shape::Ring</a>&gt;::create(300, 85),<br />                                  28, 30);<br />  sys.add(primary);<br /><br />  <a class="coderef" href="Sys_Mirror_class_reference.html">Sys::Mirror</a>             secondary(<a class="coderef" href="Math_namespace_reference.html#__654">Math::VectorPair3</a>(0, 0, 225, 0, 0, -1), 675, -5.0434, 100);<br />  sys.add(secondary);<br /><br />  <a class="coderef" href="Sys_Image_class_reference.html">Sys::Image</a>              image(<a class="coderef" href="Math_namespace_reference.html#__654">Math::VectorPair3</a>(0, 0, 900), 15);<br />  sys.add(image);<br /><br />  <a class="coderef" href="Sys_Stop_class_reference.html">Sys::Stop</a>               stop(<a class="coderef" href="Math_namespace_reference.html#__679">Math::vector3_0</a>, 300);<br />  sys.add(stop);<br />  sys.set_entrance_pupil(stop);<br /><br />  <a class="coderef" href="Sys_SourcePoint_class_reference.html">Sys::SourcePoint</a>        source(<a class="coderef" href="Sys_namespace_reference.html#__1192">Sys::SourceAtInfinity</a>, <a class="coderef" href="Math_namespace_reference.html#__680">Math::vector3_001</a>);<br />  sys.add(source);<br /></code></div></div></div></div><div class="foot"><p class="generated"><a style="float: right;" href="http://validator.w3.org/check?uri=referer">Valid XHTML 1.0 Strict</a>Generated by diaxen on Wed Nov  2 21:06:46 2011 using <a href="http://www.nongnu.org/mkdoc/">MkDoc</a></p></div></body></html>